{"version":3,"sources":["RecordMachine.ts","Recorder.tsx","Abcer.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["recorderMachineOptions","actions","recordingEffect","ctx","evt","mediaRecorder","start","services","mutateMyAnswers","Promise","res","rej","setTimeout","guards","activities","delays","recorderMachineConfig","id","on","CLOSE","sendParent","initial","context","content","canRecord","blob","audioURL","states","idle","invoke","src","navigator","mediaDevices","getUserMedia","audio","then","stream","catch","err","onDone","assign","MediaRecorder","data","onError","RECORD","target","cond","stopped","stop","ondataavailable","e","chunks","push","Blob","window","URL","createObjectURL","_ctx","recorded","playing","PAUSE","paused","PLAY","SEND","TRASH","recording","onEntry","STOP","sending","extendedOptions","Recorder","useMachine","MediaStream","send","state","matches","value","disabled","onClick","controls","className","JSON","stringify","Abcer","useState","inputValue","setInputValue","abcerMachineConfig","useEffect","console","log","onChange","type","payload","TYPED","typed","loading","success","failure","studentMachineConfig","ABC","Machine","abcing","App","alt","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","error","message"],"mappings":"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","file":"static/js/main.d11c5c01.chunk.js","sourcesContent":["import { EventObject, MachineConfig, actions, StateSchema, MachineOptions, sendParent, assign } from 'xstate';\r\n\r\n\r\nconst recordingEffect = (ctx: any, evt: any) => {\r\n    ctx.mediaRecorder.start()\r\n}\r\n\r\nexport interface RecorderContext {\r\n    content: string;\r\n    canRecord: boolean;\r\n    mediaRecorder: any;\r\n    blob: any;\r\n    audioURL: any;\r\n}\r\n\r\nexport interface RecorderStateSchema extends StateSchema {\r\n    states: {\r\n        idle: {};\r\n        recording: {};\r\n        stopped: any;\r\n        recorded: any;\r\n        sending: {};\r\n    }\r\n}\r\n\r\nexport type EventId = \"STOP\" | \"RECORD\" | \"PLAY\" | \"PAUSE\" | \"SEND\" | \"TRASH\" | \"CLOSE\"\r\n\r\nexport interface RecorderEvent extends EventObject {\r\n    type: EventId\r\n    payload: any\r\n}\r\nexport interface RecorderMachineOptions extends MachineOptions<RecorderContext, RecorderEvent> {\r\n\r\n}\r\nexport const recorderMachineOptions: RecorderMachineOptions = {\r\n    actions: {\r\n        recordingEffect\r\n    },\r\n    services: {\r\n        mutateMyAnswers: () => new Promise((res, rej) => setTimeout(() => res(), 1000)),\r\n    },\r\n    guards: {\r\n    },\r\n    activities: {},\r\n    delays: {}\r\n}\r\n\r\nexport const recorderMachineConfig: MachineConfig<RecorderContext, RecorderStateSchema, RecorderEvent> = {\r\n    id: \"recorderMachine\",\r\n    on: {\r\n        CLOSE: {\r\n            actions: sendParent(\"CLOSE\")\r\n        }\r\n    },\r\n    initial: 'idle',\r\n    context: {\r\n        content: \"\",\r\n        canRecord: false,\r\n        mediaRecorder: null,\r\n        blob: null,\r\n        audioURL: \"\"\r\n    },\r\n    states: {\r\n        idle: {\r\n            invoke: {\r\n                src: () => {\r\n                    return new Promise((res, rej) => {\r\n                        const constraints = { audio: true };\r\n                        return navigator.mediaDevices.getUserMedia(constraints)\r\n                            .then((stream) => res(stream))\r\n                            .catch((err) => rej(err))\r\n                    })\r\n                },\r\n                onDone: {\r\n                    actions: assign((ctx, evt) => ({ canRecord: true, mediaRecorder: new MediaRecorder(evt.data) }))\r\n                },\r\n                onError: {\r\n                    actions: assign((ctx, evt) => ({ canRecord: false }))\r\n                },\r\n            },\r\n            on: {\r\n                RECORD: {\r\n                    target: \"recording\",\r\n                    cond: (ctx, evt) => ctx.canRecord\r\n                },\r\n            },\r\n        },\r\n        stopped: {\r\n            invoke: {\r\n                src: (ctx, evt) => new Promise((res, rej) => {\r\n                    ctx.mediaRecorder.stop();\r\n                    ctx.mediaRecorder.ondataavailable = (e: any) => {\r\n                        const chunks = [];\r\n                        chunks.push(e.data);\r\n                        res({\r\n                            blob: new Blob(chunks, { 'type': 'audio/ogg; codecs=opus' }),\r\n                            audioURL: window.URL.createObjectURL(e.data)\r\n                        })\r\n                    }\r\n                }),\r\n                onDone: {\r\n                    target: \"recorded\",\r\n                    actions: assign((_ctx, { data: { blob, audioURL } }) => ({ blob, audioURL }))\r\n                },\r\n            },\r\n        },\r\n        recorded: {\r\n            initial: \"paused\",\r\n            states: {\r\n                playing: { on: { PAUSE: \"paused\" } },\r\n                paused: { on: { PLAY: \"playing\" } }\r\n            },\r\n            on: {\r\n                SEND: {\r\n                    target: \"sending\",\r\n                },\r\n                TRASH: {\r\n                    target: \"idle\",\r\n                    actions: (ctx, evt) => ctx.content = \"\"\r\n                }\r\n            }\r\n        },\r\n        recording: {\r\n            onEntry: [\"recordingEffect\"],\r\n            // after: {\r\n            //     500: [\r\n            //         {\r\n            //             target: \"recording\",\r\n            //             cond: (ctx) => ctx.content.length < 10\r\n            //         },\r\n            //         {\r\n            //             target: \"recorded\"\r\n            //         }\r\n            //     ]\r\n            // },\r\n            on: {\r\n                STOP: {\r\n                    target: \"stopped\",\r\n                },\r\n            }\r\n        },\r\n        sending: {\r\n            invoke: {\r\n                src: \"mutateMyAnswers\",\r\n                onDone: {\r\n                    target: \"idle\"\r\n                },\r\n                onError: {\r\n                    target: 'recorded'\r\n                }\r\n            },\r\n        },\r\n    }\r\n}","import React, { useEffect } from 'react';\r\nimport { useMachine } from 'use-machine';\r\nimport { assign } from 'xstate';\r\nimport { recorderMachineConfig, RecorderStateSchema, RecorderEvent, recorderMachineOptions, RecorderContext, RecorderMachineOptions } from './RecordMachine'\r\n\r\n\r\nconst extendedOptions: RecorderMachineOptions = {\r\n    ...recorderMachineOptions,\r\n\r\n}\r\n\r\nfunction Recorder() {\r\n    const { send, state: { matches, value }, context } = useMachine<RecorderStateSchema, RecorderEvent, RecorderContext>(recorderMachineConfig, extendedOptions, {\r\n        content: \"\",\r\n        canRecord: false,\r\n        mediaRecorder: new MediaRecorder(new MediaStream()),\r\n        blob: null,\r\n        audioURL: \"\"\r\n    })\r\n\r\n    // const constraints = { audio: true };\r\n    // var chunks: any = [];\r\n    // let mediaRecorder: MediaRecorder = new MediaRecorder(new MediaStream());\r\n    // useEffect(() => {\r\n    //     if (stream !== null) {\r\n    //         mediaRecorder = new MediaRecorder(stream);\r\n    //     }\r\n    // }, [stream])\r\n\r\n    const handleRecord = () => {\r\n        // mediaRecorder.start();\r\n        // if (mediaRecorder.state === \"recording\") {\r\n        send(\"RECORD\")\r\n        // }\r\n    }\r\n\r\n    // const onSuccess = (stream: any) => {\r\n    //     const mediaRecorder = new MediaRecorder(stream);\r\n    //     mediaRecorder.start()\r\n    //     console.log(mediaRecorder)\r\n    // }\r\n    // const onError = (...args: any) => {\r\n    //     console.log(args)\r\n    // }\r\n    // navigator.mediaDevices.getUserMedia(constraints).then(onSuccess)\r\n    // console.log(\"blob\", context.blob)\r\n    // console.log(\"audioURL\", context.audioURL)\r\n    // useEffect(() => { console.log(audioURL) }, [audioURL])\r\n\r\n    return (\r\n        <>\r\n            <div>\r\n                {(matches(\"recording\") || matches(\"recorded\")) && <div>{context.content}</div>}\r\n                <header >\r\n                    {matches(\"idle\") && <button disabled={!context.canRecord} onClick={handleRecord}>🔴</button>}\r\n                    {matches(\"recording\") && <button onClick={() => send(\"STOP\")}>stop</button>}\r\n                    {matches(\"recorded\") && <>\r\n                        <audio controls src={context.audioURL}></audio>\r\n\r\n                        <button onClick={() => send(\"SEND\")}>send</button>\r\n                        <button onClick={() => send(\"TRASH\")}>trash</button>\r\n                    </>}\r\n                </header>\r\n\r\n                {matches(\"sending\") && <div>sending...</div>}\r\n            </div>\r\n            <pre className=\"context\">{JSON.stringify(context, null, 2)}</pre>\r\n            <pre className=\"machineValue\">\r\n                {JSON.stringify(value, null, 2)}\r\n            </pre>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default Recorder;","import React, { useState, EventHandler, ReactEventHandler, useEffect } from 'react';\r\nimport { useMachine } from 'use-machine';\r\nimport { MachineConfig, StateSchema, EventObject } from 'xstate';\r\nimport { assign, sendParent } from 'xstate/lib/actions';\r\n\r\nconst mutateMyAnswers = () => new Promise((res, rej) => setTimeout(() => {\r\n    rej()\r\n}, 2000));\r\n\r\nconst Abcer = () => {\r\n    const [inputValue, setInputValue] = useState(\"\");\r\n\r\n    const { send, state: { value, matches }, context } = useMachine<AbcerStateSchema, AbcerEvent, AbcerContext>(abcerMachineConfig, { services: { mutateMyAnswers } }, { content: \"\" });\r\n\r\n    const handleInputChange = (e: any) => {\r\n        if (matches(\"idle\") || matches(\"failure\")) {\r\n            console.log(value)\r\n            send(\"TYPED\");\r\n        }\r\n        setInputValue(e.target.value);\r\n    }\r\n    const handleSend = () => {\r\n        console.log('sent')\r\n        send({ type: \"SEND\", payload: inputValue })\r\n    }\r\n    const handleTrash = () => {\r\n        setInputValue(\"\")\r\n        send(\"TRASH\")\r\n    }\r\n    useEffect(() => {\r\n        if (matches(\"success\")) {\r\n            console.log(\"success\");\r\n        } else if (matches(\"failure\")) {\r\n            console.log(\"failure\", context);\r\n        }\r\n    }, [value])\r\n\r\n    return (\r\n        <>\r\n            <input value={inputValue} onChange={handleInputChange} />\r\n            {(matches(\"typed\") || matches(\"failure\")) && <>\r\n                <button onClick={handleSend}>send</button>\r\n                <button onClick={handleTrash}>trash</button>\r\n            </>}\r\n            {matches(\"failure\") &&\r\n                <span>error. pls retry</span>\r\n            }\r\n        </>\r\n    );\r\n}\r\n\r\nexport default Abcer;\r\n\r\n\r\ninterface AbcerContext {\r\n    content: string;\r\n}\r\n\r\ninterface AbcerStateSchema extends StateSchema {\r\n    states: {\r\n        idle: {};\r\n        typed: {};\r\n        loading: {};\r\n        success: {};\r\n        failure: any\r\n    }\r\n}\r\n\r\ntype EventId = \"TYPED\" | \"SEND\" | \"TRASH\" | \"CLOSE\"\r\n\r\ninterface AbcerEvent extends EventObject {\r\n    type: EventId;\r\n    payload: any\r\n}\r\n\r\nexport const abcerMachineConfig: MachineConfig<AbcerContext, AbcerStateSchema, AbcerEvent> = {\r\n    id: 'abcerMachine',\r\n    initial: 'idle',\r\n    on: {\r\n        CLOSE: {\r\n            actions: sendParent(\"CLOSE\")\r\n        }\r\n    },\r\n    states: {\r\n        idle: {\r\n            on: {\r\n                TYPED: \"typed\"\r\n            }\r\n        },\r\n        typed: {\r\n            on: {\r\n                SEND: {\r\n                    target: \"loading\",\r\n                    actions: assign((ctx, evt: AbcerEvent) => ({ content: evt.payload }))\r\n                },\r\n                TRASH: {\r\n                    target: \"idle\",\r\n                    actions: assign((ctx, evt) => ({ content: \"\" }))\r\n                }\r\n            }\r\n        },\r\n        loading: {\r\n            invoke: {\r\n                src: \"mutateMyAnswers\",\r\n                onDone: {\r\n                    target: \"success\"\r\n                },\r\n                onError: {\r\n                    target: \"failure\",\r\n                }\r\n            },\r\n        },\r\n        success: {\r\n        },\r\n        failure: {\r\n            on: {\r\n                SEND: 'loading',\r\n                TRASH: {\r\n                    target: \"idle\",\r\n                    actions: assign((ctx, evt) => ({ content: \"\" }))\r\n                },\r\n                TYPED: \"typed\"\r\n            }\r\n        }\r\n    }\r\n}","import \"./App.css\"\nimport React from 'react';\nimport Recorder from './Recorder'\nimport Abcer from './Abcer'\nimport { useMachine } from 'use-machine';\nimport { MachineConfig, StateSchema, EventObject, Machine } from 'xstate';\nimport { recorderMachineConfig } from './RecordMachine'\nimport { abcerMachineConfig } from './Abcer'\n\ninterface StudentStateSchema extends StateSchema {\n  states: {\n    idle: {};\n    recording: any;\n    abcing: any\n  }\n}\n\nconst studentMachineConfig: MachineConfig<{}, StudentStateSchema, EventObject> = {\n  id: \"studentMachine\",\n  initial: \"idle\",\n  states: {\n    idle: {\n      on: {\n        ABC: \"abcing\",\n        RECORD: \"recording\"\n      }\n    },\n    recording: {\n      invoke: {\n        src: Machine(recorderMachineConfig)\n      },\n      on: {\n        CLOSE: \"idle\"\n      }\n    },\n    abcing: {\n      invoke: {\n        src: Machine(abcerMachineConfig)\n      },\n      on: {\n        CLOSE: \"idle\"\n      }\n    }\n  }\n}\n\nfunction App() {\n  const { state: { matches }, send } = useMachine(studentMachineConfig, {}, { content: \"\" })\n\n  return (\n    <div className=\"App\">\n      <div className=\"topSide\">\n        <div className=\"board\">\n          <img alt=\"board\" />\n        </div>\n\n        <div className=\"launcher\">\n          {matches(\"idle\") && <>\n            <button onClick={() => send(\"ABC\")}>ABC</button>\n            <button onClick={() => send(\"RECORD\")}>RECORD</button>\n          </>}\n        </div>\n      </div>\n\n      {!matches(\"idle\") && <div className=\"controlBoard\">\n        <button className=\"close-btn\" onClick={() => send(\"CLOSE\")}>X</button>\n        {matches(\"abcing\") && <Abcer />}\n        {matches(\"recording\") && <Recorder />}\n      </div>}\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}